---
layout: post
title: AspNetCoreRateLimit con límites basados en claims de identidad
image: /images/aspnetcore.png
author: Vicente José Moreno Escobar
categories: ASP.NET-Core IdentityServer4
published: false 
---
![netcore](/images/aspnetcore.png)
> HttpClientFactory es una fábrica bien fundamentada, disponible desde .NET Core 2.1, para crear instancias de HttpClient con el fin de usarlas en las aplicaciones. 

#### Conociendo le problema y su solución: ####

En muy habitual que en el desarrollo de APIs modernas necesitemos establecer límites sobre las solicitudes que son realizadas por un cliente. 
Ya sea por necesidades de negocio o para estar a salvo de hotlinkers o de atacantes debemos proteger siempre nuestras Apis con alguna solución de límite de solicitudes.

Atendiendo a esta necesidad existen múltiples soluciones que podemos implementar. Una de ellas es la que presento hoy y a la que voy a intentar dar un cuarto de vuelta. 


#### AspNetCoreRateLimits de Stefan Prodan ####

Se trata de el proyecto AspNetCoreRateLimits. Es un proyecto disponible en GitHub y también como Nuget. Este proyecto ha sido desarrollado por Stefan Prodan
(https://stefanprodan.com/) (https://github.com/stefanprodan/AspNetCoreRateLimit)


Si antes decíamos que crear uno cada vez esta mal y que crearlos de manera *“estática”* tambien esta mal ¿Cómo y qué hace esta factoría?

La respuesta es que cada vez que se solicita un objeto **HttpClient** de la factoría **IHttpClientFactory** mediante Inyector de Dependencias, esta devuelve una instancia nueva. La clave para manejarlas es todas estas instancias usan un controlador que las agrupa del tipo **IHttpMessageHandler** y que es el encargado de reducir y optimizar el uso de los recursos a la hora de que nuestras instancias se comuniquen con los recursos externos y por tanto abstraernos de los problemas antes mencionados.

Este IHttpMessageHandlers que agrupará varias instancias de **HttpClient** asociadas a un servicio concreto tienen un tiempo de refresco de 2 minutos. Después de los cuales renovarán las conexiones de las instancias de **HttpClient** que agrupen.
Esta configuración es manejable por nosotros si así lo deseamos pero eso llegará mas adelante.

Y sin mas pasamos a una pequeña parte de código con la que ilustrar el ejemplo mas básico de uso:

<details> 
  <summary>SPOILER</summary>
   Casi seguro que nunca la vas a usar de esta manera que te voy a contar.
</details>

Registraremos un servicio de tipo **IHttpClientFactory** en nuestra colección de servicios que representa nuestro Inyector de Dependencias mediante: 

`services.AddHttpClient();`

Esta invocación registrara (detras del telon) unos cuantos servicios entre los que está una implementación de IClientFactory

En nuestro ValuesController lo usaremos así:

<script src="https://gist.github.com/vicentt/09872bd8e3f892b4238c9b3ae823dcd7.js"></script>

Aquí estamos añadiendo una dependencia a IHttpClientFactory en nuestro constructor que será inyectada por el sistema de inyección de dependencias. Con IHttpClientFactory que nos es inyectada podemos pedir nuevos HttpClients.

En nuestra acción Get estamos usando HttpClientFactory para crear un nuevo cliente y a partir de aquí podremos hacer uso de él.

En siguientes post veremos maneras mas avanzadas de usar esta factoría asi como las cosas tan interesantes que nos permite realizar.

[Docu Microsoft](https://docs.microsoft.com/es-es/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)


