---
layout: post
title: AspNetCoreRateLimit con límites basados en claims de identidad
image: /images/aspnetcore.png
author: Vicente José Moreno Escobar
categories: ASP.NET-Core IdentityServer4
published: false 
---
![netcore](/images/aspnetcore.png)
> HttpClientFactory es una fábrica bien fundamentada, disponible desde .NET Core 2.1, para crear instancias de HttpClient con el fin de usarlas en las aplicaciones. 

#### Conociendo le problema y su solución: ####

En muy habitual que en el desarrollo de APIs modernas necesitemos establecer límites sobre las solicitudes que son realizadas por un cliente. 
Ya sea por necesidades de negocio o para estar a salvo de hotlinkers o de atacantes debemos proteger siempre nuestras Apis con alguna solución de límite de solicitudes.

Atendiendo a esta necesidad existen múltiples soluciones que podemos implementar. Una de ellas es la que presento hoy y a la que voy a intentar dar un cuarto de vuelta. 

#### AspNetCoreRateLimits de Stefan Prodan ####

Se trata del proyecto AspNetCoreRateLimits. Es un proyecto disponible en GitHub y también como Nuget. Este proyecto ha sido desarrollado por Stefan Prodan
[El autor](https://stefanprodan.com/) [Repo GitHub](https://github.com/stefanprodan/AspNetCoreRateLimit)

En mi opinión es un buen producto y cumple con lo que promete pero tiene una cuestión que creo que puede hacer difícil su implementación en proyectos reales.
Toda la configuración a cerca de limites parte del fichero de configuración appsettings.json. Esto puede ser problemático debido a que lo más probable es que necesitemos que esa configuración sea más dinámica.

#### Extendiendo la funcionalidad de AspNetCoreRateLimits ####
Nuestra necesidad es la de identificar a los clientes y sus límites a partir de la información de identidad que hemos adquirido cuando se han identificado para usar nuestra Api.

He creado un proyecto de ejemplo muy sencillo para ilustrar...
[Repo GitHub del Ejemplo](https://github.com/vicentt/AspNetCoreRateLimitWhitIdentity)

El proyecto de ejemplo se compone de una solución en la que tenemos una Api, un Cliente y un IdentityServer4 que levantaremos en memoria

En la Api se usa AspCoreRateLimit para establecer límites de solicitudes. Vamos a tener dos EndPoints. Uno en el que necesitaremos autorización y otro con acceso anónimo. De la autorización se va a encargar una instancia de IdentityServer4 levantado en memoria. El flow de autorización elegido ha sido Clientcredentials por motivos de sencillez y la claridad del ejemplo.

El cliente va a acceder a la Api tanto de manera autorizada como de manera anónima mediante un clientId y secret que tenemos configurado en el IdentityServer.
Gracias a una de las grandes evoluciones que nos trae .Net Core que es la facilidad en la extensión de las funcionalidades que nos ofrecen las librerías, vamos a poder extender su funcionalidad del producto

En las propias instrucciones de implementación del proyecto Stefan nos indica cómo podemos hacerlo.

Para conseguir nuestro objetivo debemos proveer AspNetCoreRateLimits de una manera de identificar al objeto de limitación. En este caso va a ser el cliente(clientId) pero podríamos utilizar otros criterios
Esto vamos a hacerlo proveyendo a la librería de una configuración creada por nosotros para tal efecto.

<script src="https://gist.github.com/vicentt/1c0af52924285866a0a6f3b01f6beacc.js"></script>

Utilizamos IHttpContextAccessor inyectado mediante DI en startup.cs y se lo pasamos a una clase llamada IdentityResolveContributor. En esta clase existe un método ResolveClient descrito en la interface IClientResolveContributor de AspNetCoreRateLimits que será el usado por la librería para obtener la identidad en la que se basarán las políticas de límites. 

En este método usaremos HttpContext de de la solicitud para extraer las características(Claims) del cliente que se ha identificado. En este caso usaremos el Client_Id que es el claim que se usa en ClientCredentials para identificar al cliente. En caso de que no tengamos cliente identificado, devolvemos “anon”.

<script src="https://gist.github.com/vicentt/92b2466e33826d222f992fe2dcac3564.js"></script>


<details> 
  <summary>SPOILER</summary>
   Casi seguro que nunca la vas a usar de esta manera que te voy a contar.
</details>

Registraremos un servicio de tipo **IHttpClientFactory** en nuestra colección de servicios que representa nuestro Inyector de Dependencias mediante: 

`services.AddHttpClient();`

Esta invocación registrara (detras del telon) unos cuantos servicios entre los que está una implementación de IClientFactory

En nuestro ValuesController lo usaremos así:

<script src="https://gist.github.com/vicentt/09872bd8e3f892b4238c9b3ae823dcd7.js"></script>

Aquí estamos añadiendo una dependencia a IHttpClientFactory en nuestro constructor que será inyectada por el sistema de inyección de dependencias. Con IHttpClientFactory que nos es inyectada podemos pedir nuevos HttpClients.

En nuestra acción Get estamos usando HttpClientFactory para crear un nuevo cliente y a partir de aquí podremos hacer uso de él.

En siguientes post veremos maneras mas avanzadas de usar esta factoría asi como las cosas tan interesantes que nos permite realizar.

[Docu Microsoft](https://docs.microsoft.com/es-es/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)


